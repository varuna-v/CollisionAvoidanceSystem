//*******************************************************
//* File:    C:/Users/User/Desktop/Third Year Project/CollisionAvoidanceSystem/Aircraft.pd
//* Author:  Varuna
//* Created: 11:49:59 on Thursday January 8th 2015 UTC
//*******************************************************

class Aircraft ^=
abstract

	//Time added to hypothetical time to get maximum time before potential conflict is declared
	const safetyTime ^= 0.3; //seconds
	const verticalBreakPoint ^= 8800.00; //meters
	const flytimeForHypotheticalCollisionAnalysis ^= 0.01; //seconds
	const cosOfDescentAngle ^= 0.99; //cos 3.0 degrees
	
	var position : Vector;
	var velocity : Vector; // km or m per sec
	var boundaryRadius : real; // km or m as above
	var status : AircraftStatus;
	var identification : string;
	var conflictStatus : ConflictStatus;
	var model : AircraftModel;
	var isElevatingOrDescending : bool;
	var targetHeight : real;
	
	invariant position.type = VectorType Position;
	invariant velocity.type = VectorType Velocity;
	invariant ~identification.empty;

confined
	
	function futureConflict(other : Aircraft) : bool
		^= getMinimumDistanceBetweenPaths(other) <= getBiggerRadius(other);
	
	function getMinimumDistanceBetweenPaths(other : Aircraft) : real
		^= (let tForMinD ^= getTimeToMinimumDistanceBetweenPaths(other);
			([tForMinD < 0.0] : 100000.00, //any large number
			 [] : positionAfterFlying(tForMinD).getDistanceFrom(other.positionAfterFlying(tForMinD))));
	
	function getSquareOfMagnitudeOfPostionOfOtherWRTThis(other : Aircraft) : QuadraticEquation
		^= (let q1 ^= VectorWithVariables{position.x, position.y, position.z, velocity.x, velocity.y, velocity.z};
		   let q2 ^= VectorWithVariables{other.position.x, other.position.y, other.position.z, other.velocity.x, other.velocity.y, other.velocity.z};
		   let q21 ^= q2 - q1;
		   q21.squareOfMagnitude);
	
	function getTimeToMinimumDistanceBetweenPaths(other : Aircraft) : real
		^= (let magSquare ^= getSquareOfMagnitudeOfPostionOfOtherWRTThis(other);
		   magSquare.getXForMinimumValue);
	
	function getBiggerRadius(other : Aircraft) : real
		^= ([boundaryRadius > other.boundaryRadius] : boundaryRadius,
			[] : other.boundaryRadius);
	
	function isInConflictWith(other : Aircraft) : bool
		^= (let biggerRadius ^= getBiggerRadius(other);
			position.getTwoDimensionalDistanceFrom(other.position) <= biggerRadius);
			
	function timeToCollision(other : Aircraft) : real
		pre ~isInConflictWith(other) & other.velocity ~= velocity
		^= (let velocityDifference ^= other.velocity - velocity;
			((position - other.position).dotProduct(velocityDifference)/((velocityDifference.magnitude)^2)));
		//!!assert result >= 0.00;
	
	//Minimum time to collision if the only info is that the aircrafts are not in conflict
	function timeToHypotheticalCollisionWith(other : Aircraft) : real
		pre ~isInConflictWith(other) & other.velocity ~= velocity
		^= (let smallerRadius ^= ([boundaryRadius < other.boundaryRadius] : boundaryRadius,
															[] : other.boundaryRadius);
									   smallerRadius/(velocity-other.velocity).magnitude)
		assert result > timeToCollision(other); //as they are not in conflict
	
	function isFlyingTowards(other : Aircraft) : bool
		^= positionAfterFlying(flytimeForHypotheticalCollisionAnalysis).getTwoDimensionalDistanceFrom(other.positionAfterFlying(flytimeForHypotheticalCollisionAnalysis)) < position.getTwoDimensionalDistanceFrom(other.position);
	
	function getCosineOfAngleForClimb : real
		^= ([model = AircraftModel Boeing777200 | model = AircraftModel Boeing777300] : 0.97, //cos 14.0,
			[model = AircraftModel Boeing737300 | model = AircraftModel Boeing737400 | model = AircraftModel Boeing737500] : 0.96, //cos15.0
			[model = AircraftModel Boeing717] : 0.95, //cos 17.0
			[model = AircraftModel Boeing737600 | model = AircraftModel Boeing737900] : 0.96, //cos 15.5
			[model = AircraftModel BoeingMD80] : 0.95, //cos 17.0
			[model = AircraftModel Boeing747400] : 0.96, //cos15.0
			[model = AircraftModel BoeingMD90] : 0.95, //cos 17.0
			[model = AircraftModel Boeing757200 | model = AircraftModel Boeing767400] : 0.96, //cos15.0
			[model = AircraftModel BoeingMD11] : 0.94); //cos 20.0
			
	function getVelocityForAscentOrDescent(isAscent : bool) : Vector
		^= (let cosOfAngle ^= ([isAscent] : getCosineOfAngleForClimb,
							   [] : cosOfDescentAngle);
			let vx2plusvy2 ^= (((velocity.x) ^ 2) + ((velocity.y) ^ 2));
			let vz ^= (((vx2plusvy2/((cosOfAngle)*(vx2plusvy2 ^ (0.5)))) ^ 2) - (vx2plusvy2)) ^ (0.5);//calculated using dot product
			let elevationMultiplier ^= ([isAscent] : 1.0,
										[] : -1.0);
			Vector{velocity.x, velocity.y, vz * elevationMultiplier, VectorType Velocity});
			
	function hasCrossedTargetHeight(newPosition : Vector) : bool
		^= isElevatingOrDescending & ((position.z < targetHeight & targetHeight <= newPosition.z) 
										| (position.z > targetHeight & targetHeight >= newPosition.z));
	
	function getPositionAfterStraightFlight(time : real, velocityForFlight : Vector, startPosition : Vector) : Vector
		^= startPosition.plus((velocityForFlight * time), VectorType Position);
		
	function getTimeToTargetHeight : real
		^= (targetHeight - position.z) / velocity.z;
	
	build{!position : Vector, !velocity : Vector, !isElevatingOrDescending : bool, !targetHeight : real, !boundaryRadius : real, !status : AircraftStatus, !identification : string, !model : AircraftModel}
		pre  position.type = VectorType Position & velocity.type = VectorType Velocity
		post conflictStatus != ConflictStatus NoConflict;
		
	build{!position : Vector, !velocity : Vector, !isElevatingOrDescending : bool, !targetHeight : real, !boundaryRadius : real, !status : AircraftStatus, !identification : string, !conflictStatus : ConflictStatus, !model : AircraftModel}
		pre  position.type = VectorType Position & velocity.type = VectorType Velocity;
			
interface	

	function conflictStatus;
	
	function position;
	
	function velocity;
	
	function boundaryRadius;
	
	function identification;
	
	function speed : real
		^= velocity.magnitude;
		
	function breaksMinimumVerticalSeparation(other : Aircraft) : bool
		^= (let heightDifference ^= ([other.position.y > position.y] : other.position.y - position.y,
									 [] : position.y - other.position.y);
			([position.y <= verticalBreakPoint & other.position.y <= verticalBreakPoint] : heightDifference < 300.00, //meters
			[] : heightDifference < 600.00)); //meters
	
	function getConflictStatus(other : Aircraft) : ConflictStatus
		^= ([~breaksMinimumVerticalSeparation(other)] : ConflictStatus NoConflict,
			[isInConflictWith(other)] : ConflictStatus Conflicted,
			[other.velocity ~= velocity & futureConflict(other)] : ConflictStatus PotentialFutureConflict,
			[] : ConflictStatus NoConflict);
		 //assert result = other.getConflictStatus(self);
		 
	function positionAfterFlying(time : real) : Vector
		^= position.plus((velocity * time), VectorType Position);
	
	function getCraftAfterFlying(time : real) : Aircraft
		^= (let posAfterStraightFlight ^= positionAfterFlying(time);
			([hasCrossedTargetHeight(posAfterStraightFlight)] : (let timeToTarget ^= getTimeToTargetHeight; //!!assert timeToTarget < time
										 let posAtTarget ^= positionAfterFlying(timeToTarget);
										 let newVelocity ^= Vector{velocity.x, velocity.y, VectorType Velocity};
										 let newPos ^= getPositionAfterStraightFlight(time - timeToTarget, newVelocity, posAtTarget);
										 Aircraft {newPos, newVelocity, false, 0.0, boundaryRadius, status, identification, model})
										,
			[] : Aircraft {posAfterStraightFlight, velocity, isElevatingOrDescending, targetHeight, boundaryRadius, status, identification, model}));
	
	function timeToConflict(other : Aircraft) : real
		^= ([~futureConflict(other)] : 100000.00, //any large number
			[] : (let magSquare ^= getSquareOfMagnitudeOfPostionOfOtherWRTThis(other);
				  let eqn ^= magSquare - QuadraticEquation{0.0, 0.0, (getBiggerRadius(other) ^ 2.0)};
				  eqn.getXForMinimumValue));
				  
	redefine function toString : string
		^= "\t Position: " ++ position.toString ++ "<br>\t Velocity: " ++ velocity.toString ++ "<br>\t Conflict Status: " ++ conflictStatus.toString;
	
	//operator =(other : Aircraft) : bool
		//^= identification = other.identification;
	
	function getCraftWithConflictStatus(cs : ConflictStatus) : Aircraft
		^= Aircraft{position, velocity, isElevatingOrDescending, targetHeight, boundaryRadius, status, identification, cs, model};
	
	function getCraftTargettingHeight(heightToTarget : real) : Aircraft
		^= ([heightToTarget = position.z] : Aircraft{position, velocity, isElevatingOrDescending, targetHeight, boundaryRadius, status, identification, model},
			[] : Aircraft{position, getVelocityForAscentOrDescent(heightToTarget > position.z), true, heightToTarget, boundaryRadius, status, identification, model});
			
	build{!position : Vector, !velocity : Vector, !boundaryRadius : real, !status : AircraftStatus, !identification : string, !model : AircraftModel}
		pre  position.type = VectorType Position & velocity.type = VectorType Velocity & ~identification.empty
		post conflictStatus != ConflictStatus NoConflict,
			isElevatingOrDescending != false,
			targetHeight != 0.0;
	
end;

